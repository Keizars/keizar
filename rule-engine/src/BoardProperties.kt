package org.keizar.game

import kotlinx.serialization.Serializable
import org.keizar.game.tilearrangement.StandardTileArrangementFactory
import kotlin.math.absoluteValue
import kotlin.random.Random

/***
 * Defines the basic game rules
 */
@Serializable
data class BoardProperties(
    // board width
    val width: Int = 8,

    // board height
    val height: Int = 8,

    // position of the keizar tile
    val keizarTilePos: BoardPos = BoardPos.fromString("d5"),

    // number of turns needed to stay on th keizar tile in order to win the game
    val winningCount: Int = 3,

    // role (black/white) that plays first
    val startingRole: Role = Role.WHITE,

    // number of rounds in one complete game
    // meaningful values are 1 or 2
    val rounds: Int = 2,

    // list of initial positions of the pieces for each role (black/white)
    val piecesStartingPos: Map<Role, List<BoardPos>>,

    // arrangement of tiles, could be generated by a TileArrangement factory
    val tileArrangement: Map<BoardPos, TileType>,

    // random seed used by TileArrangement factory
    val seed: Int? = null,
) {

    fun tileBackgroundColor(row: Int, col: Int): Boolean = (row + col) % 2 == 0

    companion object {
        fun generateRandomSeed(): Int = Random.nextInt().absoluteValue // Use absolute value so easier to share

        fun getStandardProperties(randomSeed: Int? = null): BoardProperties {
            val seed = randomSeed ?: generateRandomSeed()
            val keizarTilePos: BoardPos = BoardPos.fromString("d5")

            val piecesStartingPos: Map<Role, List<BoardPos>> = mapOf(
                Role.WHITE to BoardPos.range("a1" to "h2"),
                Role.BLACK to BoardPos.range("a7" to "h8"),
            )

            val standardTileArrangement = StandardTileArrangementFactory {
                random(Random(seed))
                fixAs(TileType.KEIZAR) {
                    listOf(keizarTilePos)
                }
                fixAs(TileType.PLAIN) {
                    listOf(
                        "a1", "b1", "g1", "h1", "c2", "d2", "e2", "f2",
                        "a8", "b8", "g8", "h8", "c7", "d7", "e7", "f7",
                    ).map { BoardPos.fromString(it) }
                }
                randomlyPut(TileType.QUEEN, TileType.BISHOP, TileType.KNIGHT, TileType.ROOK) {
                    BoardPos.range("a1" to "h4").filter { it.color == TileColor.BLACK }
                }
                randomlyPut(TileType.KING, TileType.BISHOP, TileType.KNIGHT, TileType.ROOK) {
                    BoardPos.range("a1" to "h4").filter { it.color == TileColor.WHITE }
                }
                randomlyPut(TileType.KING, TileType.BISHOP, TileType.KNIGHT, TileType.ROOK) {
                    BoardPos.range("a5" to "h8").filter { it.color == TileColor.BLACK }
                }
                randomlyPut(TileType.QUEEN, TileType.BISHOP, TileType.KNIGHT, TileType.ROOK) {
                    BoardPos.range("a5" to "h8").filter { it.color == TileColor.WHITE }
                }
                fillWith(TileType.PLAIN) {
                    BoardPos.range("a1" to "h8")
                }
            }.build()

            return BoardProperties(
                width = 8,
                height = 8,
                keizarTilePos = keizarTilePos,
                winningCount = 3,
                startingRole = Role.WHITE,
                piecesStartingPos = piecesStartingPos,
                tileArrangement = standardTileArrangement,
                seed = seed,
            )
        }
    }
}

val BoardProperties.boardPoses: Sequence<BoardPos>
    get() = sequence {
        for (row in 0 until height) {
            for (col in 0 until width) {
                yield(BoardPos(row, col))
            }
        }
    }